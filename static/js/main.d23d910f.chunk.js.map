{"version":3,"sources":["utils.js","Board.js","ReactCheckers.js","Opponent.js","Game.js","index.js"],"names":["isOdd","n","Math","abs","getColAsInt","columns","coordinate","charAt","getColAsAlph","columnInt","key","hasOwnProperty","getRowAsInt","parseInt","returnPlayerName","playerBool","Square","props","squareClasses","onClick","className","Board","coordinates","boardRender","columnsRender","moves","this","boardState","col","utils","row","currentPlayer","colorClass","push","activePiece","indexOf","moveClass","player","isKing","join","renderSquare","length","reverse","React","Component","ReactCheckers","columnLeft","columnRight","rowUpper","rowLower","corners","leftUpper","rightUpper","leftLower","rightLower","hasJumped","movesOut","jumps","killJumps","getCorners","advanceRow","cornerCoordinates","neighborPiece","opponentCorners","potentialJump","concat","killJumpsOut","state","currentState","Object","assign","history","stepNumber","movingPiece","jumpArray","jumpKills","shouldKing","object","value","newMoves","setCurrentPlayer","setActivePiece","keys","find","getMoves","stateOut","winner","evaluateWinner","player1Pieces","player1Moves","player2Pieces","player2Moves","moveCount","Opponent","computerMoves","currentSquare","pieceMoves","getComputerMoves","moveKeys","superMoves","m","piece","movesData","jumpMoves","jumpCoordinates","highestScore","bestMove","a","moveTo","score","stateLeaf","newJumpMoves","finalMove","highestAllMoves","pieces","pieceMove","moveScore","chooseMove","floor","random","out","randomPiece","randomMoveTo","browserHistory","createBrowserHistory","Game","setColumns","players","createBoard","board","initPlayers","console","log","self","forEach","i","createPiece","location","slice","getCurrentState","clickedSquare","postMoveState","movePiece","updateStatePostMove","computerTurn","setState","setTimeout","computerMove","getSmartMove","backStep","unsetHistory","gameStatus","stateHistory","undoClass","Router","basename","setPlayers","handleClick","undo","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.d23d910f.chunk.js","sourcesContent":["export function isOdd(n) {\n    return Math.abs(n % 2) === 1;\n}\n\nexport function getKeyByValue(object, value) {\n    return Object.keys(object).find(key => object[key] === value);\n}\n\nexport function getColAsInt(columns, coordinate) {\n    return columns[coordinate.charAt(0)];\n}\n\nexport function getColAsAlph(columns, columnInt) {\n\n    for (let key in columns) {\n        if (!columns.hasOwnProperty(key)) {\n            continue;\n        }\n\n        if (columnInt === columns[key]) {\n            return key;\n        }\n    }\n\n    return false;\n}\n\nexport function getRowAsInt(coordinate) {\n    return parseInt(coordinate.charAt(1), 10);\n}\n\nexport function returnPlayerName(playerBool) {\n    return playerBool === true ? 'player1' : 'player2';\n}","import React from 'react';\nimport * as utils from './utils.js';\n\n\n//função que cria cada uma das casas do tabuleiro.\nfunction Square(props) {\n    //recebe as props de classe e clique.\n    const squareClasses = props['squareClasses'];\n    const onClick = props['onClick'];\n    //e retorna um \"botão\" com as propriedades definidas.\n    return (\n        <button className = { \"square \" + (squareClasses) } onClick={onClick} />\n    );\n}\n\n//aqui a classe do tabuleiro que vai tratar de renderizar cada uma das casas.\nclass Board extends React.Component {\n    //recebe como propriedade as coordenadas e a classe e retorna um elemento\n    //Square com uma chave, classe e definição de ação no clique.\n    renderSquare(coordinates, squareClasses) {\n        return (\n            <Square\n                key = {coordinates}\n                squareClasses = {squareClasses}\n                onClick = {() => this.props.onClick(coordinates) }\n            />\n        );\n    }\n    //no render temos 2 arrays vazios, um para o tabuleiro e outro para colunas.\n    render() {\n        let boardRender = [];\n        let columnsRender = [];\n        //os movimentos são armazenados em uma constante que recebe as props de moves.\n        const moves = this.props.moves;\n        //com um for in vamos trabalhar as coordenadas...\n        for (let coordinates in this.props.boardState) {\n            //se o boardState não tiver suas coordenadas o código segue.\n            //esse hasOwnProperty é um método do React que verifica se aquele objeto tem \n            //a propriedade indicada, no caso coordenadas.\n            if (!this.props.boardState.hasOwnProperty(coordinates)) {\n                continue;\n            }\n            //duas const são criadas, uma pra coluna e outra pra linha.\n            //esse getColasInt é uma função do arqtuivo utils.js que \n            //recebe como argumento a coluna e coordenada e retorna columns[coordinate.charAt(0)], \n            //ou seja um coluna com o 1º caractere da coordenada.\n            const col = utils.getColAsInt(this.props.columns, coordinates);\n            //mesma coisa aqui mas aqui retorna parseInt(coordinate.charAt(1), 10);\n            //ou seja faz um parseInt no 2º carcatere da coordenada em uma base decimal.\n            const row = utils.getRowAsInt(coordinates);\n\n            //aqui se define o jogador por um booleano: se true é o P1, se false é o p2.\n            //esse returnPlayerName lá em utils.js retorna playerBool === true ? 'player1' : 'player2';\n            const currentPlayer = utils.returnPlayerName(this.props.currentPlayer);\n\n            //para definir a cor ce cada quadradinho se faz da seguinte forma:\n            //se tanto coluna quanto linha forem ímpares (Math.abs(n % 2) === 1;) é branco. \n            //Se linha e colunas NÃO forem ímapres é preto. \n            const colorClass  = ( (utils.isOdd(col) && utils.isOdd(row)) || (!utils.isOdd(col) && !(utils.isOdd(row)) ) ) ? 'white' : 'black';\n\n            //daí tudo é armazenado em um array.\n            let squareClasses = [];\n\n            //e nesse array damos um push tanto nas coordenadas quanto nas classes de cor. \n            squareClasses.push(coordinates);\n            squareClasses.push(colorClass);\n\n            //daí são feitas algumas verificações: se a peça selecionada for igual às coordenadas\n            //é feito um push no array squareClasses com a string 'isActive'.\n            if (this.props.activePiece === coordinates) {\n                squareClasses.push('isActive');\n            }\n\n            //se o índice de coordenadas da const moves for maior que -1 (ou seja, se existir algo lá)\n            //ele cria uma variável chamada moveClass e atribui a ela o valor de movable junto do \n            //player e da string '-move'. Também faz um push em squareclass com essa variável moveClass.\n            if (moves.indexOf(coordinates) > -1) {\n                let moveClass = 'movable ' + currentPlayer + '-move';\n                squareClasses.push(moveClass);\n            }\n\n            //se tiver no boardState alguma coordenada esse if faz um push no squareClass com \n            //as coordenadas oriundas das props desse player junto da string 'piece'.\n            if (this.props.boardState[coordinates] !== null) {\n                squareClasses.push(this.props.boardState[coordinates].player + ' piece');\n\n                //e se for Dama ele joga lá no array também...\n                if (this.props.boardState[coordinates].isKing === true ) {\n                    squareClasses.push('king');\n                }\n            }\n\n            //junta tudo que tiver no array tirando os espaços.\n            squareClasses = squareClasses.join(' ');\n            //AQui dei un console log pra ficar mais claro o funcionamento:\n            //O tabuleiro é desenhado da seguinte forma: colunas de \"a\" até \"h\" e linhas de 1 até 8.\n            //começamos com o square a1 que fica no canto inferior esquerdo. A8 fica no superior esquerdo.\n            //h1 fica no canto inferior direito e assim por diante. \n            //Esse array vai mostrar cada quadradinho, se é branco ou preto, se tem peça em cima de qual \n            //jogador, se a peça \"x\" está selecionada e qual célula desse tabuleiro é movível, ou seja, pode\n            //receber a peça que está selecionada. \n            //A cada seleção de peça e a cada movimento o array é atualizado.\n            //console.log(squareClasses)\n\n            //o clumnsRender foi um array vazio que criamos lá no começo desse código e agora \n            //vamos dar um push nele usando a função de renderSquare mandando os atributos de coordenada, etc.\n            //essa função está lá no início tbm e é responsável por renderizar cada square com as informações certinhas. \n            columnsRender.push(this.renderSquare(coordinates, squareClasses, this.props.boardState[coordinates]));\n            \n            //esse if verifica se o comprimento de columnsRender é maior ou igual a 8 e se for atribui a\n            //esse array o seu valor em ordem inversa.\n            if (columnsRender.length >= 8) {\n                columnsRender = columnsRender.reverse();\n                //o boardRender é outro array criado lá no início e dentro desse if vamos também dar um push\n                //nele com uma div contendo a classe \"board-col\" e retornando o valor de columnsRender.\n                //no final vamos zerar o columnsRender por atribuir a ele mais uma vez um array vazio.\n                boardRender.push(<div key={boardRender.length} className=\"board-col\">{columnsRender}</div>);\n                columnsRender = [];\n                \n            }\n        }\n        //tudo isso que está no Render vai culminar em um return de boardRender.\n        return (boardRender);\n    }\n}\n\nexport default Board;","import * as utils from './utils.js';\n\nexport class ReactCheckers {\n\n    constructor(columns) {\n        this.columns = columns;\n    }\n\n    getCorners(coordinates) {\n\n        const col = utils.getColAsInt(this.columns, coordinates);\n        const row = utils.getRowAsInt(coordinates);\n\n        const columnLeft  = col -1 >= 0 ? utils.getColAsAlph(this.columns, col - 1) : false;\n        const columnRight = col +1 <= 7 ? utils.getColAsAlph(this.columns, col + 1) : false;\n\n        const rowUpper = row +1 < 9 ? row +1 : false;\n        const rowLower = row -1 > 0 ? row -1 : false;\n\n        let corners = {};\n\n        corners.leftUpper  = columnLeft  !== false && rowUpper !== false ? columnLeft  + rowUpper : null;\n        corners.rightUpper = columnRight !== false && rowUpper !== false ? columnRight + rowUpper : null;\n        corners.leftLower  = columnLeft  !== false && rowLower !== false ? columnLeft  + rowLower : null;\n        corners.rightLower = columnRight !== false && rowLower !== false ? columnRight + rowLower : null;\n\n        return corners;\n    }\n\n    getMoves(boardState, coordinates, isKing = false, hasJumped = false) {\n\n        if (boardState[coordinates] === null) {\n            return [];\n        }\n\n        let moves = [];\n        let jumps = [];\n\n        let killJumps = {};\n\n        const corners = this.getCorners(coordinates);\n\n        const row = utils.getRowAsInt(coordinates);\n        const player = boardState[coordinates].player;\n\n        const advanceRow = player === 'player1' ? row - 1 : row + 1;\n\n        for (let key in corners) {\n            if (!corners.hasOwnProperty(key)) {\n                continue;\n            }\n\n            let cornerCoordinates = corners[key];\n\n            if (cornerCoordinates === null) {\n                continue;\n            }\n\n            if (!isKing && cornerCoordinates.indexOf(advanceRow) < 0) {\n                continue;\n            }\n\n            if (boardState[cornerCoordinates] === null) {\n                moves.push(cornerCoordinates);\n            } else {\n                let neighborPiece = boardState[cornerCoordinates];\n\n                if (neighborPiece.player === player) {\n                    continue;\n                }\n\n                let opponentCorners = this.getCorners(cornerCoordinates);\n                let potentialJump = opponentCorners[key];\n\n                if (boardState[potentialJump] === null) {\n                    killJumps[cornerCoordinates] = potentialJump;\n                    jumps.push(potentialJump);\n                }\n            }\n        }\n\n        let movesOut;\n\n        if (hasJumped === false) {\n            movesOut = moves.concat(jumps);\n        } else {\n            // If the piece has already jumped, only additional jumps are available\n            movesOut = jumps;\n        }\n\n        let killJumpsOut = jumps.length > 0 ? killJumps : null;\n\n        return [movesOut, killJumpsOut];\n\n    }\n\n    movePiece(coordinates, state) {\n        let currentState  = Object.assign({}, state.history[state.stepNumber]);\n        let boardState = Object.assign({}, currentState.boardState);\n        let movingPiece = Object.assign({}, boardState[state.activePiece]);\n\n        let jumpArray = [];\n\n        for (let key in state.jumpKills) {\n            if (!state.jumpKills.hasOwnProperty(key)) {\n                continue;\n            }\n\n            jumpArray.push(state.jumpKills[key]);\n        }\n\n        // Don't move if the coordinates don't match a moveable or jumpable square.\n        if (state.moves.indexOf(coordinates) < 0 && jumpArray.indexOf(coordinates) < 0) {\n            return null;\n        }\n\n        // King me maybe?\n        if (this.shouldKing(movingPiece, coordinates)) {\n            movingPiece.isKing = true;\n        }\n\n        // Move piece to new coordinates\n        boardState[state.activePiece] = null;\n        boardState[coordinates] = movingPiece;\n\n        // Remove opponent piece if jump is made\n        const player = movingPiece.player;\n        let hasJumped = null;\n        let newMoves = [];\n        let setCurrentPlayer = player === 'player2';\n        let setActivePiece = null;\n\n        if (jumpArray.indexOf(coordinates) > -1) {\n            let opponentPosition = utils.getKeyByValue(state.jumpKills, coordinates);\n            boardState[opponentPosition] = null;\n\n            newMoves = this.getMoves(boardState, coordinates, movingPiece.isKing, true);\n\n            if (newMoves[0].length > 0) {\n                hasJumped = true;\n                setCurrentPlayer = currentState.currentPlayer;\n                setActivePiece = coordinates;\n            } else {\n                hasJumped = null;\n            }\n        }\n\n        if (hasJumped === true) {\n            if (newMoves[0].length > 0) {\n                setCurrentPlayer = currentState.currentPlayer;\n                setActivePiece = coordinates;\n            }\n        }\n\n        let stateOut = {};\n\n        stateOut.boardState = boardState;\n        stateOut.currentPlayer = setCurrentPlayer;\n        stateOut.activePiece = setActivePiece;\n        stateOut.moves = hasJumped === true ? newMoves[0] : [];\n        stateOut.jumpKills = hasJumped === true ? newMoves[1] : null;\n        stateOut.hasJumped = hasJumped === true ? player : null;\n        stateOut.winner = this.evaluateWinner(boardState);\n\n        return stateOut;\n    }\n\n    shouldKing(movingPiece, coordinates) {\n\n        if (movingPiece.isKing === true) {\n            return false;\n        }\n\n        const row = utils.getRowAsInt(coordinates);\n        const player = movingPiece.player;\n\n        return ( (row === 1 && player === 'player1') || (row === 8 && player === 'player2') );\n    }\n\n    evaluateWinner(boardState) {\n\n        let player1Pieces = 0;\n        let player1Moves  = 0;\n\n        let player2Pieces = 0;\n        let player2Moves  = 0;\n\n        for (let coordinates in boardState) {\n            if (!boardState.hasOwnProperty(coordinates) || boardState[coordinates] === null) {\n                continue;\n            }\n\n            const movesData = this.getMoves(boardState, coordinates, boardState[coordinates].isKing, false);\n            const moveCount = movesData[0].length;\n\n            if (boardState[coordinates].player === 'player1') {\n                ++player1Pieces;\n                player1Moves += moveCount;\n\n            } else {\n                ++player2Pieces;\n                player2Moves += moveCount;\n            }\n        }\n\n        if (player1Pieces === 0 ) {\n            return 'player2pieces';\n        }\n\n        if (player2Pieces === 0 ) {\n            return 'player1pieces';\n        }\n\n        if (player1Moves === 0) {\n            return 'player2moves';\n        }\n\n        if (player2Moves === 0) {\n            return 'player1moves';\n        }\n\n        return null;\n    }\n}","import {ReactCheckers} from './ReactCheckers.js';\n\nexport class Opponent extends ReactCheckers {\n\n    getComputerMoves(boardState, player) {\n        const self = this;\n        let computerMoves = {};\n\n        for (const coordinates in boardState) {\n            if (!boardState.hasOwnProperty(coordinates)) {\n                continue;\n            }\n\n            const currentSquare = boardState[coordinates];\n\n            if (currentSquare == null) {\n                continue;\n            }\n\n            if (currentSquare.player !== player) {\n                continue;\n            }\n\n            const pieceMoves = self.getMoves(boardState, coordinates, boardState[coordinates].isKing, false);\n\n            if (pieceMoves[0].length > 0 || pieceMoves[1] !== null) {\n                computerMoves[coordinates] = pieceMoves;\n            }\n        }\n\n        return computerMoves;\n    }\n\n    getSmartMove(state, boardState, player) {\n        const computerMoves = this.getComputerMoves(boardState, player);\n\n        const moveKeys = Object.keys(computerMoves);\n\n        const superMoves = {};\n\n        // Pieces\n        for (let m = 0; m < moveKeys.length ; ++m) {\n            const piece = moveKeys[m];\n\n            const movesData = computerMoves[piece][0];\n            const jumpKills = computerMoves[piece][1];\n\n            const jumpMoves = [];\n\n            for (const jumpCoordinates in jumpKills) {\n                if (!jumpKills.hasOwnProperty(jumpCoordinates)) {\n                    continue;\n                }\n                jumpMoves.push(jumpKills[jumpCoordinates]);\n            }\n\n            let highestScore = 0;\n            let bestMove = null;\n\n            // Piece moves\n            for (let a = 0; a < movesData.length ; ++a) {\n\n                const moveTo = movesData[a];\n\n                let score = 0;\n\n                // let boardStateLeaf = Object.assign({}, boardstate);\n                let stateLeaf = Object.assign({}, state);\n\n                stateLeaf.activePiece = piece;\n                stateLeaf.moves = movesData;\n                stateLeaf.jumpKills = jumpKills;\n\n                if (jumpMoves.indexOf(moveTo) > -1) {\n                    score += 10;\n                }\n\n                while (stateLeaf.currentPlayer === false) {\n\n                    const newJumpMoves = this.getMoves(stateLeaf, stateLeaf.activePiece, stateLeaf.activePiece.isKing, true);\n\n                    stateLeaf.moves = newJumpMoves[0];\n                    stateLeaf.jumpKills = newJumpMoves[1];\n\n                    score += 10;\n                }\n\n                if (score >= highestScore) {\n                    highestScore = score;\n                    bestMove = moveTo;\n                }\n            }\n\n            superMoves[piece] = [bestMove, highestScore];\n        }\n\n        let finalMove = [];\n        let highestAllMoves = 0;\n\n        for (let pieces in superMoves) {\n            if (!superMoves.hasOwnProperty(pieces)) {\n                continue;\n            }\n\n            const pieceMove = superMoves[pieces][0];\n            const moveScore = superMoves[pieces][1];\n\n            if (moveScore >= highestAllMoves) {\n                if (moveScore === highestAllMoves) {\n                    finalMove.push([pieces, pieceMove]);\n                }\n                if (moveScore > highestAllMoves) {\n                    finalMove = [];\n                    finalMove.push([pieces, pieceMove]);\n                    highestAllMoves = moveScore;\n                }\n            }\n        }\n\n        const chooseMove = finalMove[Math.floor(Math.random()*finalMove.length)];\n\n        const out = {};\n        out.piece = chooseMove[0];\n        out.moveTo = chooseMove[1];\n\n        return out;\n    }\n\n    getRandomMove(boardState, player) {\n        const computerMoves = this.getComputerMoves(boardState, player);\n        const keys = Object.keys(computerMoves);\n        const randomPiece = keys[Math.floor(Math.random() * keys.length)];\n\n        const movesData    = computerMoves[randomPiece][0];\n        const randomMoveTo = movesData[Math.floor(Math.random()*movesData.length)];\n\n        let out = {};\n        out.piece = randomPiece;\n        out.moveTo = randomMoveTo;\n\n        return out;\n    }\n}","import React from 'react';\nimport Board from './Board.js';\nimport {returnPlayerName} from './utils.js';\nimport {ReactCheckers} from './ReactCheckers.js';\nimport { Router } from 'react-router-dom'\nimport {createBrowserHistory} from 'history'\nimport {Opponent} from './Opponent.js';\n\n\n//esse createBrowserHistory é da biblioteca history que importamos há pouco e\n//ela permite gerenciar o histórico da sessão. Ela cria um objeto que\n//fornece um API que nos permite consultar, navegar e usar dados entre sessões.\nconst browserHistory = createBrowserHistory();\n\n\n//agora vamos criar uma classe para o jogo propriamente dito, com algumas atribuições\n//de valor:\nexport class Game extends React.Component {\n    constructor(props) {\n        super(props);\n        this.columns = this.setColumns();\n        this.ReactCheckers = new ReactCheckers(this.columns);\n        this.Opponent = new Opponent(this.columns);\n\n        //no state vai um objeto com os seus valores iniciais:\n        this.state = {\n            players: null,\n            history: [{\n                boardState: this.createBoard(),\n                currentPlayer: true,\n            }],\n            activePiece: null,\n            moves: [],\n            jumpKills: null,\n            hasJumped: null,\n            stepNumber: 0,\n            winner: null,\n        }\n    }\n\n    //aqui a função que servirrá de base para a const columns que começa como\n    //um objeto com estas atribuições de valor.\n    setColumns() {\n        const columns = {};\n        columns.a = 0;\n        columns.b = 1;\n        columns.c = 2;\n        columns.d = 3;\n        columns.e = 4;\n        columns.f = 5;\n        columns.g = 6;\n        columns.h = 7;\n        \n        return columns;\n    }\n\n    //aqui uma função que cria o tabuleiro no jogo.\n    //lá no Board.js criamos o tabuleiro mas aqui vamos inicializar ele\n    //indicando que casa tem qual peça, de que jogador é a peça e se ela é dama.  \n    createBoard() {\n        let board = {};\n        for (let key in this.columns) {\n            if (this.columns.hasOwnProperty(key)) {\n                for (let n = 1; n <= 8 ; ++n) {\n                    let row = key + n;\n                    board[row] = null;\n                }\n            }\n        }\n        board = this.initPlayers(board);\n        //aqui é possível ver o objeto com a distribuição das peças e suas informações.\n        console.log(board)\n        return board;\n    }\n\n    //aqui os arrays com o \"mapa\" das peças de cada jogador no início do jogo. \n    initPlayers(board) {\n        const player1 = ['a8', 'c8', 'e8', 'g8', 'b7', 'd7', 'f7', 'h7', 'a6', 'c6', 'e6', 'g6',];\n        const player2 = ['b3', 'd3', 'f3', 'h3', 'a2', 'c2', 'e2', 'g2', 'b1', 'd1', 'f1', 'h1',];\n        let self = this;\n        //aqui fazemos um forEach para cada jogador e chamamos a função createPiece\n        //com os argumentos de localização e jogador. Ele criará uma peça para\n        //cada uma das listadas na const playerX acima.\n        player1.forEach(function (i) {\n            board[i] = self.createPiece(i, 'player1');\n        });\n        //mesma coisa para o player 2.\n        player2.forEach(function (i) {\n            board[i] = self.createPiece(i, 'player2');\n        });\n\n        //tudo isso retorna um tabuleiro.\n        return board;\n    }\n\n    //aqui a função que chamamos antes. Ela cria um objeto pra cada peça informando\n    //a sua localização, a quem pertence e se é dama.\n    createPiece(location, player) {\n        let piece = {};\n        piece.player   = player;\n        piece.location = location;\n        piece.isKing   = false;\n        return piece;\n    }\n\n    //parei por aqui.../////////////////////////////////////////////\n    getCurrentState() {\n        const history = this.state.history.slice(0, this.state.stepNumber + 1);\n        return history[history.length - 1];\n    }\n\n    handleClick(coordinates) {\n\n        if (this.state.winner !== null) {\n            return;\n        }\n\n        const currentState = this.getCurrentState();\n        const boardState = currentState.boardState;\n        const clickedSquare = boardState[coordinates];\n\n        // Clicked on a piece\n        if (clickedSquare !== null) {\n\n            // Can't select opponents pieces\n            if (clickedSquare.player !== returnPlayerName(currentState.currentPlayer)) {\n                return;\n            }\n\n            // Unset active piece if it's clicked\n            if (this.state.activePiece === coordinates && this.state.hasJumped === null) {\n                this.setState({\n                    activePiece: null,\n                    moves: [],\n                    jumpKills: null,\n                });\n                return;\n            }\n\n            // Can't choose a new piece if player has already jumped.\n            if (this.state.hasJumped !== null && boardState[coordinates] !== null) {\n                return;\n            }\n\n            // Set active piece\n            let movesData = this.ReactCheckers.getMoves(boardState, coordinates, clickedSquare.isKing, false);\n\n            this.setState({\n                activePiece: coordinates,\n                moves: movesData[0],\n                jumpKills: movesData[1],\n            });\n\n            return;\n        }\n\n        // Clicked on an empty square\n        if (this.state.activePiece === null) {\n            return;\n        }\n\n        // Moving a piece\n        if (this.state.moves.length > 0) {\n            const postMoveState = this.ReactCheckers.movePiece(coordinates, this.state);\n\n            if (postMoveState === null) {\n                return;\n            }\n\n            this.updateStatePostMove(postMoveState);\n\n            // Start computer move is the player is finished\n            if (postMoveState.currentPlayer === false && postMoveState.winner === null) {\n                this.computerTurn();\n            }\n        }\n    }\n\n    computerTurn(piece = null) {\n        if (this.state.players > 1) {\n            return;\n        }\n\n        setTimeout(()=> {\n            const currentState = this.getCurrentState();\n            const boardState = currentState.boardState;\n\n            let computerMove;\n            let coordinates;\n            let moveTo;\n\n            // If var piece != null, the piece has previously jumped.\n            if (piece === null) {\n                //computerMove = this.Opponent.getRandomMove(boardState, 'player2');\n                computerMove = this.Opponent.getSmartMove(this.state, boardState, 'player2');\n                \n                coordinates = computerMove.piece;\n                moveTo = computerMove.moveTo;\n            } else {\n                // Prevent the computer player from choosing another piece to move. It must move the active piece\n                computerMove = this.ReactCheckers.getMoves(boardState, piece, boardState[piece].isKing, true);\n                coordinates = piece;\n                moveTo = computerMove[0][Math.floor(Math.random()*computerMove[0].length)];\n            }\n\n            const clickedSquare = boardState[coordinates];\n\n            let movesData = this.ReactCheckers.getMoves(boardState, coordinates, clickedSquare.isKing, false);\n\n            this.setState({\n                activePiece: coordinates,\n                moves: movesData[0],\n                jumpKills: movesData[1],\n            });\n\n            setTimeout(()=> {\n                const postMoveState = this.ReactCheckers.movePiece(moveTo, this.state);\n\n                if (postMoveState === null) {\n                    return;\n                }\n\n                this.updateStatePostMove(postMoveState);\n\n                // If the computer player has jumped and is still moving, continue jump with active piece\n                if (postMoveState.currentPlayer === false) {\n                    this.computerTurn(postMoveState.activePiece);\n                }\n            },\n            500);\n        },\n        1000);\n    }\n\n    updateStatePostMove(postMoveState) {\n        this.setState({\n            history: this.state.history.concat([{\n                boardState: postMoveState.boardState,\n                currentPlayer: postMoveState.currentPlayer,\n            }]),\n            activePiece: postMoveState.activePiece,\n            moves: postMoveState.moves,\n            jumpKills: postMoveState.jumpKills,\n            hasJumped: postMoveState.hasJumped,\n            stepNumber: this.state.history.length,\n            winner: postMoveState.winner,\n        });\n    }\n\n    undo() {\n        const backStep = parseInt(this.state.stepNumber, 10) -1;\n        if (backStep < 0) {\n            return;\n        }\n        const unsetHistory = this.state.history.slice(0, backStep+1);\n        this.setState({\n            history: unsetHistory,\n            activePiece: null,\n            moves: [],\n            jumpKills: null,\n            hasJumped: null,\n            stepNumber: backStep,\n            winner: null,\n        });\n    }\n\n    setPlayers(players) {\n        this.setState({\n            players: players,\n        })\n    }\n\n    render() {\n        const columns = this.columns;\n        const stateHistory = this.state.history;\n        const activePiece = this.state.activePiece;\n        const currentState = stateHistory[this.state.stepNumber];\n        const boardState = currentState.boardState;\n        const currentPlayer = currentState.currentPlayer;\n        const moves = this.state.moves;\n\n//        console.log(this.state);\n\n        let gameStatus;\n\n        let undoClass = 'undo';\n\n        if (this.state.stepNumber < 1) {\n            undoClass += ' disabled';\n        }\n\n        switch (this.state.winner) {\n            case 'player1pieces':\n                gameStatus = 'A Vacina venceu!!!';\n                break;\n            case 'player2pieces':\n                gameStatus = 'COVID venceu... :-(';\n                break;\n            case 'player1moves':\n                gameStatus = 'Sem mais possibildiades - A vacina venceu!';\n                break;\n            case 'player2moves':\n                gameStatus = 'Sem mais possibildiades - COVID venceu... :-(';\n                break;\n            default:\n                gameStatus = currentState.currentPlayer === true ? 'Vacina' : 'COVID';\n                break;\n        }\n\n        if (this.state.players === null) {\n            return(\n                <Router history={browserHistory} basename={'react-checkers'} >\n                    <div className=\"players-select\">\n                        <div className=\"players\">\n                            <div className=\"one-player\" onClick={()=> this.setPlayers(1) }>Um jogador</div>\n                        </div>\n                        <div className=\"players\">\n                            <div className=\"two-player\" onClick={()=> this.setPlayers(2) }>Dois jogadores</div>\n                        </div>\n                    </div>\n                </Router>\n            )\n        }\n\n        return(\n            <Router history={browserHistory} basename={'react-checkers'} >\n                <div className=\"reactCheckers\">\n                    <div className=\"game-status\">\n                        {gameStatus}\n                    </div>\n                    <div className=\"game-board\">\n                        <Board\n                            boardState = {boardState}\n                            currentPlayer = {currentPlayer}\n                            activePiece = {activePiece}\n                            moves = {moves}\n                            columns = {columns}\n                            onClick = {(coordinates) => this.handleClick(coordinates)}\n                        />\n                    </div>\n                    <div className=\"time-travel\">\n                        <button className={undoClass} onClick={()=>this.undo()}>Undo</button>\n                    </div>\n                </div>\n            </Router>\n        );\n    }\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport {Game} from './Game.js';\n\n// ========================================\n\nReactDOM.render(\n    <Game />,\n    document.getElementById('root')\n);"],"sourceRoot":""}